# -*- coding: utf-8 -*-
"""Dishap_shrestha_2409012_W0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13NDWfqUXfxfghZ9k5wGSOMZj-PPqF0yT

#Name: Dishap Shrestha

#ID:2409012

Task 1. Classify Temperatures:

Datasets: The temperatures list contains daily temperature readings in Celsius for one
month in Kathmandu. Each day includes three readings representing night (00-08),
evening (08-16), and day (16-24) temperatures.
Sample Code - List of temperature measured at Tribhuwan International Airport.
"""

# List of temperatures measured
temperatures = [8.2, 17.4, 14.1, 7.9, 18.0, 13.5, 9.0, 17.8, 13.0, 8.5,
                16.5, 12.9, 7.7, 17.2, 13.3, 8.4, 16.7, 14.0, 9.5, 18.3,
                13.4, 8.1, 17.9, 14.2, 7.6, 17.0, 12.8, 8.0, 16.8, 13.7,
                7.8, 17.5, 13.6, 8.7, 17.1, 13.8, 9.2, 18.1, 13.9, 8.3,
                16.4, 12.7, 8.9, 18.2, 13.1, 7.8, 16.6, 12.5]

# Task 1: Classify Temperatures
cold = []        # Temperatures below 10°C
mild = []        # Temperatures between 10°C and 15°C
comfortable = [] # Temperatures between 15°C and 20°C

# Classify temperatures
for temp in temperatures:
    if temp < 10:
        cold.append(temp)
    elif 10 <= temp < 15:
        mild.append(temp)
    elif 15 <= temp <= 20:
        comfortable.append(temp)

# Print results for verification
print("Cold temperatures:", cold)
print("Mild temperatures:", mild)
print("Comfortable temperatures:", comfortable)

# Task 2: Based on data - Answer the questions
# Count how many times it was mild
mild_count = len(mild)

print("\nTask 2:")
print("Number of times it was mild:", mild_count)

"""2. How many times was it comfortable?
=> 16

3. How many times was it cold?
=> 16

Task 3. Convert Temperatures from Celsius to Fahrenheit

Using the formula for temperature conversion, convert each reading from Celsius to Fahren-
heit and store it in a new list called temperatures_fahrenheit.

Formula: Fahrenheit = (Celsius ×
9/
5
) + 32

1. Iterate over the temperatures list and apply the formula to convert each temperature.
2. Store the results in the new list.
3. Print the converted Fahrenheit values.
"""

# Task 3: Convert Temperatures from Celsius to Fahrenheit

# List to store converted temperatures
temperatures_fahrenheit = []

# Conversion formula and storing the result in a new list
for temp in temperatures:
    fahrenheit = (temp * 9/5) + 32
    temperatures_fahrenheit.append(fahrenheit)

# Print the converted Fahrenheit values
print("Temperatures in Fahrenheit:", temperatures_fahrenheit)

"""Task 4. Analyze Temperature Patterns by Time of Day:
Scenario: Each day’s readings are grouped as:
• Night (00-08),
• Evening (08-16),
• Day (16-24).
1. Create empty lists for night, day, and evening temperatures.
2. Iterate over the temperatures list, assigning values to each time-of-day list based on
their position.
3. Calculate and print the average day-time temperature.
4. (Optional) Plot ”day vs. temperature” using matplotlib.
"""

# Task 4: Analyze Temperature Patterns by Time of Day

# Create empty lists for night, evening, and day temperatures
night_temps = []
evening_temps = []
day_temps = []

# Step 2: Group temperatures by time of day
for i in range(0, len(temperatures), 3):  # Each day has three readings
    night_temps.append(temperatures[i])      # Night: 00-08
    evening_temps.append(temperatures[i+1]) # Evening: 08-16
    day_temps.append(temperatures[i+2])     # Day: 16-24

# Step 3: Calculate the average day-time temperature
avg_day_temp = sum(day_temps) / len(day_temps)

# Print results
print("\nTask 4:")
print("Night temperatures:", night_temps)
print("Evening temperatures:", evening_temps)
print("Day temperatures:", day_temps)
print("Average day-time temperature:", avg_day_temp)

# Step 4 (Optional): Plot "day vs. temperature" using matplotlib
import matplotlib.pyplot as plt

# Plotting day temperatures
plt.figure(figsize=(10, 5))
plt.plot(day_temps, marker='o', label='Day Temperatures', color='orange')
plt.title("Day Temperatures Over Time")
plt.xlabel("Days")
plt.ylabel("Temperature (°C)")
plt.legend()
plt.grid(True)
plt.show()

"""Exercise - Recursion:
Task 1 - Sum of Nested Lists:
Scenario: You have a list that contains numbers and other lists of numbers (nested lists).
You want to find the total sum of all the numbers in this structure.
Task:
• Write a recursive function sum_nested_list(nested_list) that:
1. Takes a nested list (a list that can contain numbers or other lists of numbers) as
input.
2. Sums all numbers at every depth level of the list, regardless of how deeply nested
the numbers are.
• Test the function with a sample nested list, such as
nested_list = [1, [2, [3, 4], 5], 6, [7, 8]].
The result should be the total sum of all the numbers.
"""

def sum_nested_list(nested_list):
    total = 0
    for element in nested_list:
        if isinstance(element, list):  # Check if the element is a list
            total += sum_nested_list(element)  # Recursively sum the nested list
        else:
            total += element  # Add the number to the total
    return total

# Test Cases
nested_list_1 = [1, [2, [3, 4], 5], 6, [7, 8]]
nested_list_2 = [1, [2, 3], [4, [5]]]

# Printing Results
print("Sum of nested_list_1:", sum_nested_list(nested_list_1))
print("Sum of nested_list_2:", sum_nested_list(nested_list_2))

"""Task 2 - Generate All Permutations of a String:
Scenario: Given a string, generate all possible permutations of its characters. This is useful
for understanding backtracking and recursive depth-first search.
Task:
• Write a recursive function generate_permutations(s) that:
– Takes a string s as input and returns a list of all unique permutations.
• Test with strings like ”abc” and ”aab”.

print(generate_permutations("abc"))
# Should return [’abc’, ’acb’, ’bac’, ’bca’, ’cab’, ’cba’]
"""

def generate_permutations_unique(s):
    """
    Generate all unique permutations of a string using a set to avoid duplicates.
    """
    if len(s) == 1:
        return [s]

    permutations = set()
    for i, char in enumerate(s):
        remaining = s[:i] + s[i+1:]
        for perm in generate_permutations_unique(remaining):
            permutations.add(char + perm)

    return list(permutations)

# Test Cases
print("Unique Permutations of 'abc':", generate_permutations_unique("abc"))  # Expected: ['abc', 'acb', 'bac', 'bca', 'cab', 'cba']
print("Unique Permutations of 'aab':", generate_permutations_unique("aab"))  # Expected: ['aab', 'aba', 'baa']

"""Task 3 - Directory Size Calculation:
Directory Size Calculation Scenario: Imagine a file system where directories can contain files
(with sizes in KB) and other directories. You want to calculate the total size of a directory,
including all nested files and subdirectories.

Sample directory structure.

# Sample directory structure
directory_structure = {
"file1.txt": 200,
"file2.txt": 300,
"subdir1": {
"file3.txt": 400,
"file4.txt": 100
},
"subdir2": {
"subsubdir1": {
"file5.txt": 250
},

19

5CS037 Worksheet - 0 Siman Giri

"file6.txt": 150
}
}
Task:
1. Write a recursive function calculate_directory_size(directory) where:
• directory is a dictionary where keys represent file names (with values as sizes in

KB) or directory names (with values as another dictionary representing a subdi-
rectory).

• The function should return the total size of the directory, including all nested
subdirectories.
2. Test the function with a sample directory structure.
"""

def calculate_directory_size(directory):
    total_size = 0

    for key, value in directory.items():
        if isinstance(value, dict):  # If it's a subdirectory
            total_size += calculate_directory_size(value)  # Recursively calculate its size
        else:  # It's a file
            total_size += value

    return total_size

# Sample directory structure
directory_structure = {
    "file1.txt": 200,
    "file2.txt": 300,
    "subdir1": {
        "file3.txt": 400,
        "file4.txt": 100
    },
    "subdir2": {
        "subsubdir1": {
            "file5.txt": 250
        },
        "file6.txt": 150
    }
}

# Test the function
total_size = calculate_directory_size(directory_structure)
print("Total directory size:", total_size, "KB")

"""Exercises - Dynamic Programming:
Task 1 - Coin Change Problem:
Scenario: Given a set of coin denominations and a target amount, find the minimum number
of coins needed to make the amount. If it’s not possible, return - 1.
Task:
1. Write a function min_coins(coins, amount) that:
• Uses DP to calculate the minimum number of coins needed to make up the
amount.
2. Test with coins = [1, 2, 5] and amount = 11. The result should be 3 (using coins
[5, 5, 1]).
"""

def min_coins(coins, amount):
    """
    Finds the minimum number of coins needed to make up a given amount using dynamic programming.

    Args:
        coins (list of int): A list of coin denominations available for making change.
        amount (int): The target amount for which we need to find the minimum number of coins.

    Returns:
        int: The minimum number of coins required to make the given amount.
             If it is not possible to make the amount with the given coins, returns -1.

    Example:
        >>> min_coins([1, 2, 5], 11)
        3
        >>> min_coins([2], 3)
        -1
    """
    # Initialize the DP table with infinity (representing an impossible amount initially)
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0  # Base case: 0 coins are needed to make an amount of 0

    # Populate the DP table
    for coin in coins:
        for i in range(coin, amount + 1):
            dp[i] = min(dp[i], dp[i - coin] + 1)

    # If dp[amount] is still infinity, the amount cannot be made
    return dp[amount] if dp[amount] != float('inf') else -1

# Test Cases
coins = [1, 2, 5]
amount = 11
print("Minimum coins required:", min_coins(coins, amount))  # Expected: 3 (using coins [5, 5, 1])

coins = [2]
amount = 3
print("Minimum coins required:", min_coins(coins, amount))  # Expected: -1 (impossible to make 3 with coin [2])

"""Task 2 - Longest Common Subsequence (LCS):
Scenario: Given two strings, find the length of their longest common subsequence (LCS).
This is useful in text comparison.
Task:
1. Write a function longest_common_subsequence(s1, s2) that:
• Uses DP to find the length of the LCS of two strings s1 and s2.
2. Test with strings like "abcde" and "ace"; the LCS length should be 3 ("ace").
"""

def longest_common_subsequence(s1, s2):
    """
    Finds the length of the longest common subsequence (LCS) of two strings using dynamic programming.

    Args:
        s1 (str): First string.
        s2 (str): Second string.

    Returns:
        int: The length of the longest common subsequence of s1 and s2.

    Example:
        >>> longest_common_subsequence("abcde", "ace")
        3
    """
    # Lengths of the input strings
    m, n = len(s1), len(s2)

    # Create a DP table with dimensions (m+1) x (n+1)
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    # Fill the DP table
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s1[i - 1] == s2[j - 1]:  # Characters match
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:  # Characters don't match
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])

    # The length of the LCS is in dp[m][n]
    return dp[m][n]

# Test Cases
s1 = "abcde"
s2 = "ace"
print("Length of LCS:", longest_common_subsequence(s1, s2))  # Expected: 3 ("ace")

s1 = "abc"
s2 = "def"
print("Length of LCS:", longest_common_subsequence(s1, s2))  # Expected: 0 (no common subsequence)

"""Task 3 - 0/1 Knapsack Problem:
Scenario: You have a list of items, each with a weight and a value. Given a weight capacity,
maximize the total value of items you can carry without exceeding the weight capacity.
Task:
1. Write a function knapsack(weights, values, capacity) that:
• Uses DP to determine the maximum value that can be achieved within the given
weight capacity.

2. Test with weights [1, 3, 4, 5], values [1, 4, 5, 7], and capacity 7. The re-
sult should be 9.
"""

def knapsack(weights, values, capacity):
    """
    Solves the 0/1 Knapsack Problem using dynamic programming.

    Args:
        weights (list of int): List of weights of the items.
        values (list of int): List of values of the items.
        capacity (int): Maximum weight capacity of the knapsack.

    Returns:
        int: The maximum value that can be achieved within the given weight capacity.

    Example:
        >>> knapsack([1, 3, 4, 5], [1, 4, 5, 7], 7)
        9
    """
    # Number of items
    n = len(weights)

    # Create a DP table with dimensions (n+1) x (capacity+1)
    dp = [[0] * (capacity + 1) for _ in range(n + 1)]

    # Fill the DP table
    for i in range(1, n + 1):
        for w in range(1, capacity + 1):
            if weights[i - 1] <= w:  # If the current item's weight fits in the knapsack
                dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - weights[i - 1]] + values[i - 1])
            else:  # Otherwise, don't include the item
                dp[i][w] = dp[i - 1][w]

    # The maximum value is in dp[n][capacity]
    return dp[n][capacity]

# Test Case
weights = [1, 3, 4, 5]
values = [1, 4, 5, 7]
capacity = 7
print("Maximum value:", knapsack(weights, values, capacity))  # Expected: 9